# npm包共享
最容易想到的方法就是通过npm包共享，实践起来发现有如下缺点：

-   管理困难

-   单一负责人发布方式 负责人工作量很大，因为负责人需要处理代码上线关系，使得高版本包含低版本代码，而实际又经常因为进度原因，低版本后上线，对负责人要求比较高。 此外，开发发布需要和负责人沟通也是不小的成本。  
    
-   开发自行发布方式 没有自动化流程，代码包含关系难以管理，很容易出现A发布的包缺少B的代码的情况，导致线上出问题。  
    

-   先上线后测试

要部署测试环境，就必须先发布上线，由于这种不合常理的操作，需要配合诸如临时修改引用侧版本号等各种操作，操作繁琐且易出错。

# dll共享
dll共享就是将公共模块单独作为一个工程打包，最终由使用方通过script标签引用，模块内的方法通过全局变量暴露给使用方。这种方式相比其他几种方式，最大的好处是公共模块可独立升级部署。但这个模式存在以下问题：

-   重复包、按需加载问题

dll模块必须经过打包，但打包后就会造成重复打包和无法按需加载的问题。  

-   开发不便

公共模块是运行时加载的，编辑器在引用的工程内无法取得这个模块的任何定义，编辑器的补全、校验功能无法使用，降低了开发效率。如果是使用ts的话，可以考虑在公共模块写一份ts定义，在开发时，用软链接的方式把ts定义链接的引用工程，可一定程度上解决这个问题。

# submodule
submodule是之前公司用来取代npm包的做法，原理是在一个git工程（父工程）下保存另一个git工程（子工程）的commitID，通过submodule的命令可以把这个commitID的代码同步到父工程。

由于submodule实际上只是把公共模块代码作为父工程的一个目录，与父工程共同运行，所以没有npm包、dll包这种独立于工程外引用造成的各种问题，submodule本身是git的功能，整个开发过程是纯git操作，所以也没有npm包管理上的麻烦，相比npm包优势明显，目前实践下来只发现几个小问题：

-   操作略显繁琐  
    父工程会记录一个submodule的commitId，这个id一旦变化，就需要执行submodule命令重新同步这个commitId的代码到本地，也就是切换分支，拉取新代码，所有引起commitID变化的操作，都需要执行额外的submodule命令。  
      
    这个问题可以规避，通过配置git config --global submodule.recurse true，使得每次切换分支或拉取代码时，自动update一下submodule。  
      
    另外修改submodule的代码需要同时操作父工程和子工程两个git，相比只操作单一工程更加繁琐。  
    
-   学习成本  
    需要一定实践才能理解submodule的逻辑，在整个团队推广需要一些时间。

# subtree
subtree实际和submodule有很多相似的地方，网上经常被拿来对比。

-   submodule 在父工程维护子工程的git地址、当前代码绑定的commitID等，通过命令来同步这个commitID对应的代码到父工程，并且在git操作上，父工程和子工程也是分开操作的。  
    
-   subtree 不记录任何子工程的信息，每次输入命令，都必须带上git地址、分支名等信息，根据命令，把命令中指定的分支代码拷贝到本工程的指定目录，也能用命令把本工程指定目录的代码push到子工程，在开发过程中，完全不用管subtree的存在，直接当成只有一个工程开发提交就好了，等需要把代码同步到subtree仓库时再执行subtree push命令。

从表面上看，subtree有submodule好处，操作还比submodule简单，也更容易理解，因此目前团队选用了subtree作为跨工程共用代码方案，但实际并没有这么简单，详见三、subtree源码阅读。

[[subtree的使用方法]]]