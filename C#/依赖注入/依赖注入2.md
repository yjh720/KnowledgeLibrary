[C#依赖注入实例 - 醉意人间 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zuiyirenjian/archive/2012/07/24/2607378.html)

# 背景介绍
设计模式中，尤其是结构型模式很多时候解决的就是对象间的依赖关系，变依赖具体为依赖抽象。平时开发中如果发现客户程序依赖某个（或某类）对象，我们常常会对它们进行一次抽象，形成抽象的抽象类、接口，这样客户程序就可以摆脱所依赖的具体类型。

这个过程中有个环节被忽略了——**谁来选择客户程序需要的满足抽象类型的具体类型呢**？通过后面的介绍你会发现很多时候创建型模式可以比较优雅地解决这个问题。但另一问题出现了，如果您设计的不是具体业务逻辑，而是公共库或框架程序，这时候您是一个“服务方”，不是您调用那些构造类型，而是它们把抽象类型传给您，怎么松散地把加工好的抽象类型传递给客户程序就是另一回事了。

这个情形也就是常说的“控制反转”，IOC：Inverse of Control；框架程序与抽象类型的调用关系就像常说的好莱坞规则：Don’t call me, I’ll call you.

参考Martin Fowler在《Inversion of Control Containers and the Dependency Injection pattern》一文，我们可以采用“依赖注入”的方式将加工好的抽象类型实例“注入”到客户程序中，本书的示例也将大量采用这种方式将各种依赖项“注入”到模式实现的外部——客户程序。下面我们结合一个具体的示例看看为什么需要依赖注入，以及Martin Fowler文中提到的三种经典方式，然后依据C#语言的特质，再扩展出一个基于Attribter方式注入（参考原有的Setter命名，这里将基于Attribute的方法称为Attributer）。

# 示例
客户程序需要一个提供System.DateTime类型当前系统时间的对象，然后根据需要仅仅把其中的年份部分提取出来，因此最初的实现代码如下：
```C#
using System;

using System.Diagnostics;

namespace MarvellousWorks.PracticalPattern.Concept.DependencyInjection.Example1

{

    class TimeProvider

    {

        public DateTime CurrentDate { get { return DateTime.Now; } }

    }

    public class Client

    {

        public int GetYear()

        {

            TimeProvider timeProvier = new TimeProvider();

            return timeProvier.CurrentDate.Year;

        }

    }

}
```

后来因为某种原因，发现使用.NET Framework自带的日期类型精度不够，需要提供其他来源的TimeProvider，确保在不同精度要求的功能模块中使用不同的TimeProvider。这样问题集中在TimeProvider的变化会影响客户程序，但其实客户程序仅需要抽象地使用其获取当前时间的方法。为此，增加一个抽象接口，确保客户程序仅依赖这个接口ITimeProvider，由于这部分客户程序仅需要精确到年，因此它可以使用一个名为SystemTimeProvider (:ITimeProvider)的类型。新的实现代码如下：
```C#
using System;

namespace   
   MarvellousWorks.PracticalPattern.Concept.DependencyInjection.Example2

{

    interface ITimeProvider

    {

        DateTime CurrentDate { get;}

    }

    class TimeProvider : ITimeProvider

    {

        public DateTime CurrentDate { get { return DateTime.Now; } }

    }

    public class Client

    {

        public int GetYear()

        {

            ITimeProvider timeProvier = new TimeProvider();

            return timeProvier.CurrentDate.Year;

        }

    }

}
```

这样看上去客户程序后续处理权都依赖于抽象的ITimeProvider，问题似乎解决了？没有，它还要知道具体的SystemTimeProvider。因此，需要增加一个对象，由它选择某种方式把ITimeProvider实例传递给客户程序，这个对象被称为Assembler。

其中，Assembler的职责如下：

l          知道每个具体TimeProviderImpl的类型。

l          可根据客户程序的需要，将抽象ITimeProvider反馈给客户程序。

l          本身还负责对TimeProviderImpl的创建。

下面是一个Assembler的示例实现：
```C#
public class Assembler

{

    /// <summary>

    /// 保存“抽象类型/实体类型”对应关系的字典

    /// </summary>

    private static Dictionary<Type, Type> dictionary =   
       new Dictionary<Type, Type>();

    static Assembler()

    {

        // 注册抽象类型需要使用的实体类型

        // 实际的配置信息可以从外层机制获得,例如通过配置定义

        dictionary.Add(typeof(ITimeProvider), typeof(SystemTimeProvider));

    }

    /// 根据客户程序需要的抽象类型选择相应的实体类型，并返回类型实例

    /// <returns>实体类型实例</returns>

    public object Create(Type type)     // 主要用于非泛型方式调用

    {

        if ((type == null) || !dictionary.ContainsKey(type)) throw new   
            NullReferenceException();

        Type targetType = dictionary[type];

        return Activator.CreateInstance(targetType);

    }

    /// <typeparam name="T">抽象类型（抽象类/接口/或者某种基类）</typeparam>

    public T Create<T>()    // 主要用于泛型方式调用

    {

        return (T)Create(typeof(T));

    }

}
```

## Constructor注入
构造函数注入，顾名思义，就是在构造函数的时候，通过Assembler或其他机制把抽象类型作为参数传递给客户类型。这种方式虽然相对其他方式有些粗糙，而且仅在构造过程中通过“一锤子”方式设置好，但很多时候我们设计上正好就需要这种Read Only的注入方式。其实现方式如下：
```C#
class Client

{

    private ITimeProvider timeProvider;

    public Client(ITimeProvider timeProvider)

    {

        this.timeProvider = timeProvider;

    }

}

Unit Test

[TestClass]

public class TestClient

{

    [TestMethod]

    public void Test()

    {

        ITimeProvider timeProvider =   
           (new Assembler()).Create<ITimeProvider>();

        Assert.IsNotNull(timeProvider);     // 确认可以正常获得抽象类型实例

        Client client = new Client(timeProvider);   // 在构造函数中注入

    }

}
```